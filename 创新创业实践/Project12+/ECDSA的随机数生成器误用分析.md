# ECDSA的随机数生成器误用分析

随机数的质量在ECDSA等算法中有着至关重要的地位，一旦能恢复出一组签名的随机数 $k$ 便能轻易还原出私钥 $sk$. 这里我们对可能的ECDSA随机数生成算法进行分析，并结合相关论文实现对其的攻击，实际上该论文的攻击流程是比较trivial的，但其涉及的思想以及其中提出的一个待解决方案在我看来比这个攻击似乎具有更高的价值

我们考虑的是某个具有多项式递推关系的PRNG，且其多项式系数未知，最后可以达到以下效果，对于度数为 $d$ 的多项式递推关系，我们只需要 $d+3$ 组连续ECDSA签名即可还原私钥 $sk$

这里我先给出该问题的代码示例，曲线数据参考区块链上的主流曲线选取，利用下述代码在开源数学软件SageMath上生成攻击示例

```python
from Crypto.Util.number import *
from hashlib import sha256

class prng:
    def __init__(self, mod, degree):
        self.seed = randint(0, mod-1)
        self.coe = [randint(0, mod-1) for _ in range(degree+1)]
        self.mod = mod
        self.degree = degree
        
    def next(self):
        self.seed = sum([self.coe[i]*self.seed^i for i in range(self.degree+1)])%self.mod
        return ZZ(self.seed)
    
def keygen():
    p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
    a = 0x0000000000000000000000000000000000000000000000000000000000000000
    b = 0x0000000000000000000000000000000000000000000000000000000000000007
    E = EllipticCurve(GF(p), [a, b])
    q = E.order()
    sk = randint(1, q-1)
    return (p, a, b, q), sk

def sign(m, pk, sk):
    p, a, b, q = pk
    k = PRNG.next()
    R = k*G
    P = sk*G
    r = ZZ(R.xy()[0])
    e = int(sha256(m.encode()).hexdigest(), 16)
    s = inverse_mod(k, q)*(e+sk*r)%q
    return (r, s)
    
    
pk, sk = keygen()
p, a, b, q = pk
E = EllipticCurve(GF(p), [a, b])
G = E.gens()[0]
d = 5
PRNG = prng(q, d)

sig = []
for _ in range(d+3):
    sig.append(sign('w3lc0m3 2 nu1l team', pk, sk))
    
print(f'sig = {sig}')
```

我们最需要关注的是签名生成的数学关系式，如下

$s = k^{-1}\cdot (h+r\cdot sk)\;mod\,q$

其中 $s,r$ 为签名输出， $h$ 为待签名信息的哈希值，$k$ 为生成的随机数，$q$ 为使用椭圆曲线的阶

我们很容易找到一个关于 $k,sk$ 之间的线性表达式

$k=s^{-1}r\cdot sk+s^{-1}h\;mod\,q$

对于连续的ecdsa签名我们可以得到多组上述线性关系

$k_i=s_i^{-1}r_i\cdot sk+s_i^{-1}h\;mod\,q\;(\star)$

到这里最简单的想法为寻找一个包含 $k_i$ 的多项式关系，这样我们将上式进行带入即可得关于私钥 $sk$ 的单变量关系式，而在素域上求解一个单变量多项式根存在多项式时间算法，即可还原 $sk$

下面对多项式关系的寻找进行阐述，实际上这也是trivial的，所以在我看来这个攻击本身并不具备多大的吸引力，只是些较为简单的trick

对于方程组 $j\in [0, n+1]$,   $\sum_{i=0}^n a_ik_j^i=k_{j+1}$

如何利用这些等式构建出不含未知 $a$ 的关于 $k$ 的等式

论文中提出了一种递归的思路，但是我觉得流程比较抽象，不是很便于理解，这里给出一种更容易理解的想法

构造矩阵，如下
$$
\left[\begin{matrix} 
1&k_0&\dots&k_0^n&k_1\\
1&k_1&\dots&k_1^n&k_2\\
&\ddots&&\ddots&\\
1&k_{n+1}&\dots&k_{n+1}^n&k_{n+2}\\
\end{matrix}\right]
$$
该矩阵为满秩矩阵，对应的第 $i$ 列为各个方程中 $a_i$ 的系数 $i\in [0,n]$，最后一列为等式右边的值

利用高斯消元，我们得到最后一行的向量 $(0,...,0,F)$， $F$ 即为我们所需多项式

最终用 $\star$ 式替换 $F$ 中的 $k_i$，在素域上求根得 $sk$

攻击实现代码如下

```python
from hashlib import sha256

pk = (115792089237316195423570985008687907853269984665640564039457584007908834671663, 0, 7, 115792089237316195423570985008687907852837564279074904382605163141518161494337)
sig = [(11618768669468112896430198191165554231504821364174808310208010001818598164107, 74750385808611783801371819922390260800624574655442859157157723699497475574791), (48579629457152161340726523841535781837843854085989349411118100679824982484607, 43493300125378289742234628919380253627222490950964450199491056508804709032703), (56420799578714759422737932047978211369100438966107158283423149606446300934773, 18914391026564052312600291710111822632127102062476512600498705624224681105724), (61511720566204893220567689914005889839803137873212794992217840584239660745262, 18453014640093998851287726928629014937674436863334501809275777495522498067370), (39642958084121264287183422674676202188108677236683700547685489665261282406308, 9932037552215989421276635865640299284928978895294141963013268183671248704421), (95979318170198945167864281924661726044175301501423619479747653179727431511592, 113138902909341762267433162642810276187683276766781570445782866055350695563196), (81838443642194040463953958519208722153189195194525921374987522784251778737257, 88952902862166267010878870878890888115535770390596094233218809594863136419502), (76677230112791109559755838766474321283166692468260002051174268775556365854643, 31200591429154089519214398328373247354552787477309599345470177213433443732557)]
n = 8
p, a, b, q = pk
h = int(sha256(b'w3lc0m3 2 nu1l team').hexdigest(), 16)


var = [f'x{_}' for _ in range(n)]+['t']
PR = PolynomialRing(ZZ, names = var)
var = PR.gens()
    
def elimination(mat):
    rows, cols = len(mat), len(mat[0])
    for i in range(rows-1):
        std = mat[i]
        coe = std[i]
        for j in range(i+1, rows):
            tar = mat[j]
            coe_ = tar[i]
            mat[j] = tar*coe-std*coe_
    return mat


def Construct(n):
    global var
    u = []
    for _ in range(n-1):
        v = []
        for i in range(n-2):
            v.append(var[_]^i)
        v.append(var[_+1])
        u.append(vector(v))
    return elimination(u)[-1][-1]


F = Construct(n)
Fq = GF(q)
Rq.<x> = PolynomialRing(Fq)
F = list(F.factor())[-1][0]
F = F.change_ring(Fq)

f = []
for _ in range(n):
    r, s = sig[_]
    f.append(inverse_mod(s, q)*r*var[-1]+inverse_mod(s, q)*h)
    

F = F.subs(x0=f[0])
F = F.subs(x1=f[1])
F = F.subs(x2=f[2])
F = F.subs(x3=f[3])
F = F.subs(x4=f[4])
F = F.subs(x5=f[5])
F = F.subs(x6=f[6])
F = F.subs(x7=f[7])

F = Rq(F.univariate_polynomial())
root = F.roots()
print(root)
```

但是值得注意的是，上面提出的寻找多项式的方式较论文中提出的递归寻找会比较慢，本质上是由于F关系较为大，进行多项式运算时需要对多项式单项进行搜索与重排将会消耗较多的时间，而论文中递归的方式一定程度地减少了此类开销，以至于上述我提出的寻找方式并不能完全将其替代，在n大于10时，单线程处理需要较长的时间，可以采用多线程并行对其优化及改进

该思路的一个主要的思想表现为在多个方程进行消元时，先考虑消除线性的变量，高次变量可以有保留地留在最后。并且在文章结尾，提出了一个非常有意思的问题，对于完全随机的k，我们可以通过重排k的产生顺序，并且对于较大的 $n$ ，高概率存在某种排序能构建出关于 $k$ 的一个高次多变量表达式，于是利用上述方法我们能对私钥进行还原，但是目前似乎没有比暴力搜索更快的方式寻找出这样的排列，并且对于找到后的多项式次数过高也会一定程度影响后续求解的速度。所以未来其研究可能是对于排列的搜索算法和更快的多项式生成方式等

## Reference

https://eprint.iacr.org/2023/305.pdf

